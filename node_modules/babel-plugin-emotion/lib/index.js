'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //  weak


exports.hashArray = hashArray;
exports.replaceCssWithCallExpression = replaceCssWithCallExpression;
exports.buildStyledCallExpression = buildStyledCallExpression;
exports.buildStyledObjectCallExpression = buildStyledObjectCallExpression;

exports.default = function (babel) {
  var t = babel.types;


  return {
    name: 'emotion', // not required
    inherits: require('babel-plugin-syntax-jsx'),
    visitor: {
      Program: {
        enter: function enter(path, state) {
          state.importedNames = _extends({}, defaultImportedNames, state.opts.importedNames);
          state.file.metadata.modules.imports.forEach(function (_ref) {
            var source = _ref.source,
                imported = _ref.imported,
                specifiers = _ref.specifiers;

            if (source.indexOf('emotion') !== -1) {
              var importedNames = specifiers.filter(function (v) {
                return ['default', 'css', 'keyframes', 'injectGlobal', 'fontFace', 'merge'].indexOf(v.imported) !== -1;
              }).reduce(function (acc, _ref2) {
                var _extends2;

                var imported = _ref2.imported,
                    local = _ref2.local;
                return _extends({}, acc, (_extends2 = {}, _extends2[imported === 'default' ? 'styled' : imported] = local, _extends2));
              }, defaultImportedNames);
              state.importedNames = _extends({}, importedNames, state.opts.importedNames);
            }
          });

          state.extractStatic =
          // path.hub.file.opts.filename !== 'unknown' ||
          state.opts.extractStatic;

          state.staticRules = [];

          state.insertStaticRules = function (staticRules) {
            var _state$staticRules;

            (_state$staticRules = state.staticRules).push.apply(_state$staticRules, staticRules);
          };
        },
        exit: function exit(path, state) {
          if (state.staticRules.length !== 0) {
            var toWrite = state.staticRules.join('\n').trim();
            var filenameArr = path.hub.file.opts.filename.split('.');
            filenameArr.pop();
            filenameArr.push('emotion', 'css');
            var cssFilename = filenameArr.join('.');
            var exists = _fs2.default.existsSync(cssFilename);
            path.node.body.unshift(t.importDeclaration([], t.stringLiteral('./' + (0, _path.basename)(cssFilename))));
            if (exists ? _fs2.default.readFileSync(cssFilename, 'utf8') !== toWrite : true) {
              if (!exists) {
                (0, _touch.touchSync)(cssFilename);
              }
              _fs2.default.writeFileSync(cssFilename, toWrite);
            }
          }
        }
      },
      JSXOpeningElement: function JSXOpeningElement(path, state) {
        (0, _cssProp2.default)(path, state, t);
      },
      CallExpression: function CallExpression(path, state) {
        if (path[visited]) {
          return;
        }
        try {
          if (t.isIdentifier(path.node.callee)) {
            switch (path.node.callee.name) {
              case state.importedNames.css:
              case state.importedNames.keyframes:
                {
                  path.addComment('leading', '#__PURE__');
                }
              // eslint-disable-next-line no-fallthrough
              case state.importedNames.injectGlobal:
              case state.importedNames.fontFace:
                if (state.opts.sourceMap === true && path.node.loc !== undefined) {
                  path.node.arguments.push(t.stringLiteral((0, _sourceMap.addSourceMaps)(path.node.loc.start, state)));
                }
            }
          }

          if (t.isCallExpression(path.node.callee) && path.node.callee.callee.name === state.importedNames.styled || t.isMemberExpression(path.node.callee) && t.isIdentifier(path.node.callee.object) && path.node.callee.object.name === state.importedNames.styled) {
            var identifier = t.isCallExpression(path.node.callee) ? path.node.callee.callee : path.node.callee.object;
            path.replaceWith(buildStyledObjectCallExpression(path, state, identifier, t));
          }
        } catch (e) {
          throw path.buildCodeFrameError(e);
        }

        path[visited] = true;
      },
      TaggedTemplateExpression: function TaggedTemplateExpression(path, state) {
        if (path[visited]) {
          return;
        }
        path[visited] = true;
        if (
        // styled.h1`color:${color};`
        t.isMemberExpression(path.node.tag) && path.node.tag.object.name === state.importedNames.styled) {
          path.replaceWith(buildStyledCallExpression(path.node.tag.object, t.stringLiteral(path.node.tag.property.name), path, state, t));
        } else if (
        // styled('h1')`color:${color};`
        t.isCallExpression(path.node.tag) && path.node.tag.callee.name === state.importedNames.styled) {
          path.replaceWith(buildStyledCallExpression(path.node.tag.callee, path.node.tag.arguments[0], path, state, t));
        } else if (t.isIdentifier(path.node.tag)) {
          if (path.node.tag.name === state.importedNames.css || path.node.tag === state.cssPropIdentifier) {
            replaceCssWithCallExpression(path, path.node.tag, state, t);
          } else if (path.node.tag.name === state.importedNames.keyframes) {
            replaceCssWithCallExpression(path, path.node.tag, state, t, function (src, name, hash) {
              return '@keyframes ' + name + '-' + hash + ' { ' + src + ' }';
            }, false, function () {
              return '';
            });
          } else if (path.node.tag.name === state.importedNames.fontFace) {
            replaceCssWithCallExpression(path, path.node.tag, state, t, function (src, name, hash) {
              return '@font-face {' + src + '}';
            }, true);
          } else if (path.node.tag.name === state.importedNames.injectGlobal) {
            replaceCssWithCallExpression(path, path.node.tag, state, t, undefined, true, function () {
              return '';
            });
          }
        }
      }
    }
  };
};

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _touch = require('touch');

var _babelUtils = require('./babel-utils');

var _emotionUtils = require('emotion-utils');

var _sourceMap = require('./source-map');

var _cssProp = require('./css-prop');

var _cssProp2 = _interopRequireDefault(_cssProp);

var _astObject = require('./ast-object');

var _astObject2 = _interopRequireDefault(_astObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function hashArray(arr) {
  return (0, _emotionUtils.hashString)(arr.join(''));
}

var staticStylis = new _emotionUtils.Stylis({ keyframe: false });

function replaceCssWithCallExpression(path, identifier, state, t) {
  var staticCSSSrcCreator = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (src) {
    return src;
  };
  var removePath = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var staticCSSSelectorCreator = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : function (name, hash) {
    return '.' + name + '-' + hash;
  };

  try {
    var _createRawStringFromT = (0, _babelUtils.createRawStringFromTemplateLiteral)(path.node.quasi),
        hash = _createRawStringFromT.hash,
        src = _createRawStringFromT.src;

    var name = (0, _babelUtils.getName)((0, _babelUtils.getIdentifierName)(path, t), 'css');

    if (state.extractStatic && !path.node.quasi.expressions.length) {
      var staticCSSRules = staticStylis(staticCSSSelectorCreator(name, hash), staticCSSSrcCreator(src, name, hash));
      state.insertStaticRules([staticCSSRules]);
      if (!removePath) {
        return path.replaceWith(t.stringLiteral(name + '-' + hash));
      }
      return path.replaceWith(t.identifier('undefined'));
    }

    if (!removePath) {
      path.addComment('leading', '#__PURE__');
    }
    if (state.opts.sourceMap === true && path.node.quasi.loc !== undefined) {
      src += (0, _sourceMap.addSourceMaps)(path.node.quasi.loc.start, state);
    }

    return path.replaceWith(t.callExpression(identifier, new _astObject2.default((0, _babelUtils.minify)(src), path.node.quasi.expressions, t).toExpressions()));
  } catch (e) {
    if (path) {
      throw path.buildCodeFrameError(e);
    }

    throw e;
  }
}

function buildStyledCallExpression(identifier, tag, path, state, t) {
  var identifierName = (0, _babelUtils.getIdentifierName)(path, t);

  if (state.extractStatic && !path.node.quasi.expressions.length) {
    var _createRawStringFromT2 = (0, _babelUtils.createRawStringFromTemplateLiteral)(path.node.quasi, identifierName, 'styled' // we don't want these styles to be merged in css``
    ),
        hash = _createRawStringFromT2.hash,
        _src = _createRawStringFromT2.src;

    var staticClassName = 'css-' + hash;
    var staticCSSRules = staticStylis('.' + staticClassName, _src);

    state.insertStaticRules([staticCSSRules]);
    return t.callExpression(t.callExpression(identifier, [tag, t.objectExpression([t.objectProperty(t.identifier('e'), t.stringLiteral(staticClassName))])]), []);
  }

  var _createRawStringFromT3 = (0, _babelUtils.createRawStringFromTemplateLiteral)(path.node.quasi),
      src = _createRawStringFromT3.src;

  path.addComment('leading', '#__PURE__');

  if (state.opts.sourceMap === true && path.node.quasi.loc !== undefined) {
    src += (0, _sourceMap.addSourceMaps)(path.node.quasi.loc.start, state);
  }
  return t.callExpression(t.callExpression(identifier, [tag]), new _astObject2.default((0, _babelUtils.minify)(src), path.node.quasi.expressions, t).toExpressions());
}

function buildStyledObjectCallExpression(path, state, identifier, t) {
  var tag = t.isCallExpression(path.node.callee) ? path.node.callee.arguments[0] : t.stringLiteral(path.node.callee.property.name);

  var args = path.node.arguments;
  if (state.opts.sourceMap === true && path.node.loc !== undefined) {
    args.push(t.stringLiteral((0, _sourceMap.addSourceMaps)(path.node.loc.start, state)));
  }
  path.addComment('leading', '#__PURE__');

  return t.callExpression(t.callExpression(identifier, [tag]), args);
}

var visited = Symbol('visited');

var defaultImportedNames = {
  styled: 'styled',
  css: 'css',
  keyframes: 'keyframes',
  injectGlobal: 'injectGlobal',
  fontFace: 'fontFace',
  merge: 'merge'
};